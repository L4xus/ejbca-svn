# File containing internal localization messages used by 
# log comments, approval notifications and some exceptions.
#
# The keys should be sections into which module the message
# originates from, example raadmin.msg1 or keyrecovery.testmessage
#
# ENGLISH VERSION

# This are resources only used with the test script
raadmin.testmsg       = Test FR                        
raadmin.testparams    = Test {0} {1} {2} {3} {4} message {0} 


services.serviceadded                    = Service {0} ajouté
services.erroraddingservice              = Erreur pendant l'ajout du service {0}
services.notauthorizedtoadd              = Erreur, vous n'êtes pas autorisé à ajouter le service {0}
services.serviceedited                   = Service {0} modifié
services.erroreditingservice             = Erreur pendant la modification du service {0}
services.notauthorizedto                 = Erreur pas d'autorisation pour le service {0}
services.servicecloned                   = Création d'un nouveau {0} à partir du service {1}
services.errorcloningservice             = Erreur pendant la création du service {0} à partir du service {1}
services.serviceremoved                  = Service {0} supprimé
services.errorremovingservice            = Suppression de la source de donnée utilisateur {0}
services.servicerenamed                  = Service {0} renommé en {1}
services.errorrenamingservice            = Erreur pendant le renommage du service {0} en {1}
services.serviceexecuted                 = Service {0} exécuté avec succès
services.servicenotfound                 = Service avec l'identifiant {0} non trouvé
services.serviceexecutionfailed          = L'exécution du service {0} a échoué
services.servicerunonothernode           = Le service {0} a été exécuté par un autre membre du cluster
services.erroractionclasspath            = Erreur de configuration du service de vérification {0}, ActionClassPath (chemin de classe) n'est pas spécifié
services.errorintervalclasspath          = Erreur de configuration du service de vérification {0}, IntervalClassPath (chemin de classe) n'est pas spécifié
services.errorworkerconfig               = L'action {0} du service {1} n'est configurée correctement, vérifier le chemin de classe (classpath)
services.certexpireworker.errornoemail   = La notification pour l'utilisateur {0} a échoué, pas d'adresse email configurée
services.certexpireworker.errorconfig    = Erreur : La notification par email de l'expiration {0} n'est pas configurée correctement, vérifier la valeur {1}
services.interval.errorconfig            = Erreur de configuration pour le service périodique {0}, vérifier la valeur de {1}
services.mailaction.errorreceiveraddress = Erreur : adresse de destination non spécifiée
services.mailaction.errorsenderaddress   = Erreur : adresse d'expéditeur non spécifiée
services.mailaction.sent                 = Notification envoyée avec succès a {0}
services.mailaction.errorsend            = Erreur pendant l'envoie de la notification à {0}
services.mailaction.erroractioninfo      = Erreur, seul le MailActionInfoe est supporté


# Notification resources

notification.newrequest.subject      = Nouveau EJBCA Approbation de requête (${approvalRequest.ID}) à ${approvalRequest.TYPE} a été conçu par ${requestAdmin.CN} ${requestAdmin.O}.

notification.newrequest.msg          = ${NL}${NL}An approval request to ${approvalRequest.TYPE} have been created by ${requestAdmin.CN} ${requestAdmin.O} at ${approvalRequest.DATE}${NL}${NL}To review and approve the request click on the link ${approvalRequest.APROVEURL} for more details. ${NL}${NL}${approvalReqiest.APPROVALSLEFT} more need to approve the action in order for it to be executed.

notification.requestconcured.subject = The EJBCA Approval Request (${approvalRequest.ID}) to ${approvalRequest.TYPE} have been concured by ${approvalAdmin.CN} ${approvalAdmin.O}.

notification.requestconcured.msg     = ${NL}${NL}The approval request to ${approvalRequest.TYPE} by ${requestAdmin.CN} ${requestAdmin.O} at ${approvalRequest.DATE} have been concured by ${approvalAdmin.CN} ${approvalAdmin.O}. ${NL}${NL}The approving administrator's comment on the action is: ${approvalRequest.APPROVALCOMMENT}${NL}${NL}But there is still a need for ${approvalReqiest.APPROVALSLEFT} authorized administrators to agree upon the action. To review and approve the request click on the link ${approvalRequest.APROVEURL} for more details. 

notification.requestapproved.subject = The EJBCA Approval Request (${approvalRequest.ID}) to ${approvalRequest.TYPE} have been APPROVED by ${approvalAdmin.CN} ${approvalAdmin.O}.

notification.requestapproved.msg     = ${NL}${NL}Depending on the type of request the requesting administrator can now access the information, or the action have been executed ${NL}${NL}The approving administrator's comment on the action is: ${approvalRequest.APPROVALCOMMENT}${NL}${NL}Click on the link ${approvalRequest.APROVEURL} for more details.

notification.requestrejected.subject = The EJBCA Approval Request (${approvalRequest.ID}) to ${approvalRequest.TYPE} have been REJECTED by ${approvalAdmin.CN} ${approvalAdmin.O}.

notification.requestrejected.msg     = ${NL}${NL}The approval request (${approvalRequest.ID}) to ${approvalRequest.TYPE} have been REJECTED by ${approvalAdmin.CN} ${approvalAdmin.O} and the action will not be performed. ${NL}${NL}The rejecting administrator's comment on the action is: ${approvalRequest.APPROVALCOMMENT}${NL}${NL}Click on the link ${approvalRequest.APROVEURL} for more details.

# Sign session resource
signsession.requestcert = Received certificate request for user {0} for CA {1} with certificate profile {2}.
signsession.nouserinrequest = Pas de nom d'utilisateur dans la requête, DN de la requête : {0}
signsession.nopasswordinrequest = Pas de mot de passe dans la requête
signsession.nokeyinrequest = Pas de clé public dans la requête
signsession.wrongauthority = L'AC de la requête ({0}) ne correspond pas aux AC de l'utilisateur ({1})
signsession.nosuchuser = Utilisateur {0} introuvable
signsession.finishnouser = Fonction finishUser appelée sur un utilisateur inexistant {0}
signsession.unsupportedkeytype = Type de clé publique non supporté ({0}), seuls les types de clés RSA et ECDSA sont supportés
signsession.illegalkeylength = Taille de clé invalide : {0}
signsession.certificateissued = Certificat émis pour l'utilisateur {0}
signsession.popverificationfailed = La vérification POP à échouée
signsession.canotactive              = L'AC de signature {0} n'est pas active
signsession.caexpired                = L'AC de signature {0} a expiré
signsession.canotyetvalid            = L'AC de signature {0} n'est pas encore valide
signsession.canotfoundissuerusername = Ne peut trouver l'identifiant de l'AC depuis le DN émetteur '{0}' ou le nom d'utilisateur '{1}'
signsession.canotfoundcaid           = Identifiant d'AC invalide : {0}
signsession.createdcrl               = Création de la LCR numéro {0} pour l'AC {1} avec le DN '{2}'
signsession.errorcreatecrl           = Erreur pendant la création de la LCR
signsession.usertypeinvalid          = L'utilisateur est marqué en USER_INVALID, impossible de créer un certificat pour cet utilisateur
signsession.errorcertprofiletype     = Mauvais profil de certificat ({0}) pour une entité finale. Seuls les profils de certificats de type "certificat final" peuvent être utilisés pour le composant de signature

# TODO
signsession.errorcertprofilenotauthorized = End Entity data contains a CA, {0}, which the Certificate Profile, {1}, isn't authorized to use.

signsession.limitingvalidity = Limitation de la validité du certificat, car la valeur de la requête ({0}) est au-delà de la validité de l'AC ({1}).

# CA Admin resources 
caadmin.notauthorizedtocreateca = L'administrateur n'est pas autorisé à créer une AC {0}
caadmin.notauthorizedtoeditca = L'administrateur n'est pas autorisé à modifier une AC {0}
caadmin.notauthorizedtoremoveca = L'administrateur n'est pas autorisé à supprimer l'AC avec l'identifiant {0}
caadmin.notauthorizedtorenameca = L'administrateur n'est pas autorisé à renommer l'AC avec l'identifiant {0}
caadmin.notauthorizedtocertreq = L'administrateur n'est pas autorisé à créer des requêtes de certificats pour l'AC {0}

#TODO 
caadmin.notauthorizedtocertresp = Administrator is not authorized to recieve certificate responce for CA {0}.
caadmin.notauthorizedtocertresp = Administrator is not authorized to process CA {0}.

caadmin.notauthorizedtorenew = L'administrateur n'est pas autorisé à renouveler l'AC {0}
caadmin.notauthorizedtorevoke = L'administrateur n'est pas autorisé à révoquer l'AC {0}
caadmin.notauthorizedtoactivatetoken = L'administrateur n'est pas autorisé à activer le token pour l'AC {0}
caadmin.notauthorizedtodeactivatetoken = L'administrateur n'est pas autorisé à désactiver le token pour l'AC {0}
caadmin.wrongcaid = Identifiant d'AC {0} invalide, impossible de créer l'AC
caadmin.caexistsid = Une AC avec l'identifiant {0} existe déjà
caadmin.caexistsname = Une AC avec le même nom {0} existe déjà 
caadmin.errorcreatetoken = Erreur pendant la création d'une AC token
caadmin.errorcreatetokenpin = Erreur pendant la création d'une AC token, authentification erronée
caadmin.errorcreateca = Impossible de créer l'AC {0}
caadmin.errorcreatecaservice = Impossible de créer le service AC externe {0}
caadmin.erroreditca = Impossible d'éditer l'AC {0}
caadmin.errorremoveca = Impossible de supprimer l'AC {0}
caadmin.errorrenameca = Impossible de renommer l'AC {0}
caadmin.errorgetcainfo = Erreur lors de la récupération des informations de l'AC {0}
caadmin.errorcertreq = Erreur pendant la création de la demande de certificat pour l'AC {0}
# TODO Check
caadmin.errorcertresp = Erreur pendant la réception de la réponse de certificat pour l'AC {0}
#caadmin.errorcertresp = Error receiving certificate response for CA {0}.
caadmin.errorprocess = Erreur lors du traitement de l'AC {0}
caadmin.errorrenewca = Erreur lors du renouvellement de l'AC {0}
caadmin.errorrevoke = Erreur lors de la révocation de l'AC {0}
caadmin.errorcertreqinternalca = Impossible de créer une demande de certificat pour une AC interne {0}
caadmin.errorcertrespinternalca = Impossibe de recevoir un certificat pour une AC interne {0}
caadmin.errorcertrespillegalmsg = Message de réponse invalide
caadmin.errorcertrespwrongdn = Le DN de la réponse ({0}) ne correspond pas au DN de la demande ({1})
caadmin.errorcaexists = Erreur lors du traitement de l'AC ({0}, l'AC existe déjà
caadmin.erroractivatetoken = Erreur lors de l'activation du token de l'AC {0}
caadmin.errordeactivatetoken = Erreur lors de la désactivation du token de l'AC {0}
caadmin.errornotoffline = l'AC {0} doit être en statut 'hors ligne' pour être activée
caadmin.errornotonline = l'AC {0} doit être en statut 'en ligne' pour être désactivée
caadmin.errorcanotfound = Erreur d'accès à l'AC {0}, l'AC ne peut être trouvée 
caadmin.errorreadingtoken = Erreur lors de la lecture des informations du token pour l'AC {0}

caadmin.createdca = AC {0} correctement créé avec le statut {1}

caadmin.editedca = Modification de l'AC {0}
caadmin.removedca = Suppression de l'AC {0}
caadmin.removedca = Renommage de l'AC {0} en {1} effectué avec succès
caadmin.processedca = Traitement de l'AC {0} effectué avec succès
caadmin.renewdca = Renouvellement de l'AC {0} effectué avec succès

caadmin.revokedca = Révocation de l'AC {0} effectué avec succès, motif : {1}
caadmin.certreqcreated = Certificate request generated successfully for CA {0}.
caadmin.certrespreceived = Certificate responce recieved successfully to CA {0}.

authorization.admingroupadded = Groupe d'administrateur {0} ajouté avec succès
authorization.erroraddadmingroup = Erreur lors de l'ajout du groupe d'administrateur {0}
authorization.admingroupremoved = Groupe d'administrateur {0} supprimé avec succès
authorization.errorremoveadmingroup = Erreur lors de la suppression du groupe d'administrateur {0}
authorization.admingrouprenamed = Groupe d'administrateur {0} renommé en {1} avec succès
authorization.errorrenameadmingroup = Erreur lors du renommage du groupe d'administrateur {0} en {1}
authorization.accessrulesadded = Droits d'accès ajoutés au groupe d'administrateur {0}
authorization.erroraddaccessrules = Erreur lors de l'ajout de droits d'accès au groupe d'administrateur {0}
authorization.accessrulesremoved = Droits d'accès supprimés au groupe d'administrateur {0}
authorization.errorremoveaccessrules = Erreur lors de la suppression de droits d'accès au groupe d'administrateur {0}
authorization.accessrulesreplaced = Droits d'accès modifiés pour le groupe d'administrateur {0}
authorization.errorreplaceaccessrules = Erreur lors de la modification des droits d'accès du groupe d'administrateur {0}
authorization.adminadded = Administrateur(s) ajouté(s) au groupe d'administrateur {0}
authorization.erroraddadmin = Erreur lors de l'ajout d'administrateur au groupe d'administrateur {0}
authorization.adminremoved = Suppression d'administrateur du groupe d'administrateur {0}
authorization.errorremoveadmin = Erreur lors de la suppression d'administrateur du groupe d'administrateur {0}
authorization.errorcreateauthtree = Erreur lors de la création de AuthorizationTreeUpdateDataBean.
authentication.invalidpwd = Requête utilisateur avec un mot de passe invalide {0}
authentication.authok = Utilisateur {0} authentifié
authentication.wrongstatus = Requête reçue avec le statut '{0}', le statut NOUVEAU, ÉCHOUÉ ou ENCOURS est requis {1}
authentication.usernotfound = Requête reçue depuis un utilisateur inexistant : {0}
authentication.statuschanged = Changement du statut, nouveau statut : GÉNÉRÉ

createcrl.createdcrl = Création d'une LCR pour l'AC {0} avec le DN : {1}
createcrl.errorcreate = Erreur lors de la création de la LCR {0} pour l'AC {1}
createcrl.caoffline = l'AC {0} {1} est hors ligne, la LCR ne peut être générée
createcrl.catokenoffline = l'AC {0} {1} matérielle est hors ligne, impossible de créer une LCR
createcrl.crlinfonull = Pas d'information disponible sur la LCR, utilisation du nombre 0 pour la prochaine mise à jour
createcrl.generalerror = Erreur lors de la génération de la LCR pour l'AC {0}
createcrl.erroravailcas = Erreur lors du listage des AC disponibles

publisher.store = Objet {0} publié avec succès pour le service {1}
publisher.errorstore = Erreur lors de la publication de {0}
publisher.nopublisher = Le service de publication {0} n'existe pas
publisher.testedpublisher = Test de connexion pour le service de publication {0} effectuée avec succès
publisher.errortestpublisher = Erreur lors du test de connexion pour le service de publication {0}
publisher.addedpublisher = Service de publication {0} ajouté
publisher.erroraddpublisher = Erreur lors de l'ajout du service de publication {0}
publisher.changedpublisher = Service de publication {0} modifié
publisher.errorchangepublisher = Erreur lors de la modification du service de publication {0}
publisher.clonedpublisher = Nouveau service de publication {0} crée à partir du service {1}
publisher.errorclonepublisher = Erreur lors de la création d'un nouveau service de publication {0} à partir du service {1}
publisher.removedpublisher = Service de publication {0} supprimé
publisher.errorremovepublisher = Erreur lors de la suppression du service de publication {1}
publisher.renamedpublisher = Service de publication {0} renommé en {1}
publisher.errorrenamepublisher = Erreur lors du renommage du service de publication {0} en {1}

store.storecert = Certificat sauvegardé
store.errorstorecert = Erreur lors de la sauvegarde du certificat
store.storecrl = LCR numéro {0} avec l'empreinte {1}
store.errorcertinfo = Impossible de trouver le certificat avec l'empreinte {0}
store.errorfindcertuser = Impossible de trouver le certificat de l'utilisateur {0}
store.errorfindcertserno = Impossible de trouver le certificat avec le numéro de série {0}
store.revokedcert = Certificat révoqué, motif : {0}
# TODO
store.republishunrevokedcert = Republished unrevoked cert, reason: {0}. 
store.ignorerevoke = Ignored setRevokeStatus() request serialNo: {0}. Current cert status: {1}. Revocation reason: {2}. 

store.revokedallbyca = Revoked All CAs certificates from issuer {0} successfully. Permantly revoked {1} certificates with reason {2}.

store.errorrevokeallbyca = Erreur pendant la révocation de tous les certificats de l'AC émis par par l'émetteur {0}
store.getcrl = Accès à la LCR depuis l'émetteur {0} avec le numéro de LCR {1}
store.errorgetcrl = Erreur d'accès à la LCR de l'émetteur {0} avec le numéro de LCR {1}
store.errorgetcrlinfo = Erreur d'accès aux informations de la LCR de l'émetteur {0}
store.errorgetcrlinfo = Error retrieving crl info for issuer {0}.
store.storehistory = Storing certificate request history successful for user {0}.
store.errorstorehistory = Error storing certificate request history for user {0}.
store.removehistory = Removal of certificate request history successful for fingerprint {0}.
store.errorremovehistory = Error removing certificate request history for fingerprint {0}.
store.errorcertprofilefixed = Error processing certificaterprofile {0}, name of fixed profile.
store.errorcertprofileexists = Le profil de certificat {0} existe déjà
store.addedcertprofile = Nouveau profil de certificat {0} crée
store.errorcreatecertprofile = Erreur pendant la création d'un nouveau profil de certificat {0}
store.erroraddprofilewithtempl = Error adding certificaterprofile {0} using profile {1} as template.
store.addedprofilewithtempl = Nouveau profil de certificat {0} crée à partir du profil existant {1}
store.removedprofile = Profil de certificat {0} supprimé
store.errorremoveprofile = Erreur pendant la suppression du profil de certificat {0}
store.renamedprofile = Profil de certificat {0} renommé en {1}
store.errorrenameprofile = Erreur pendant le renommage du profil de certificat {0} en {1}
store.editedprofile = Profile de certificat {0} modifié
store.erroreditprofile = Erreur pendant la modification du profil de certificat {0}
store.errorseveralissuerserno = Erreur dans la base de données, il existe plus d'un certificat avec le même émetteur : {0} et le même numéro de série : {1}

hardtoken.userdatasent = Userdata sent for token generation to issuer with alias {0}.
hardtoken.errorsenduserdata = Error when retrieving next token for issuer with alias {0}.
hardtoken.addedprofile = Profil de token matériel {0} ajouté 
hardtoken.erroraddprofile = Erreur pendant l'ajout d'un profil de token matériel {0}
hardtoken.editedprofile = Profil de token matériel {0} modifié
hardtoken.erroreditprofile = Erreur pendant la modification du profil de token matériel {0}
hardtoken.clonedprofile = Nouveau profil de token matériel {0} crée à partir du profil {1}
hardtoken.errorcloneprofile = Erreur pendant la création d'un nouveau profil de token matériel {1} à partir du profil {1}
hardtoken.removedprofile = Profil de token matériel {0} supprimé
hardtoken.errorremoveprofile = Erreur pendant la suppression du profil de token matériel {0}
hardtoken.renamedprofile = Profil de token matériel {0} renommé en {1}
hardtoken.errorrenameprofile = Erreur pendant le renommage du profil de token matériel {0} en {1}
hardtoken.addedissuer = Nouvel émetteur de token matériel {0}
hardtoken.erroraddissuer = Erreur pendant la création d'un nouvel émetteur de token matériel {0}
hardtoken.editedissuer = Émetteur de token matériel {0} modifié
hardtoken.erroreditissuer = Erreur pendant la modification de l'émetteur de token matériel {0}
hardtoken.clonedissuer = Nouvel émetteur de token matériel {0} à partir de l'émetteur {1}
hardtoken.errorcloneissuer = Erreur pendant la création d'un émetteur de token matériel {0} à partir de l'émetteur {1}
hardtoken.removedissuer = Émetteur de token matériel {0} supprimé
hardtoken.errorremoveissuer = Erreur pendant la suppresion de l'émetteur de token matériel {0}
hardtoken.renameissuer = Émetteur de token matériel {0} renommé en {1}
hardtoken.errorrenameissuer = Erreur pendant le renommage de l'émetteur de token matériel {0} en {1}
hardtoken.unavailabletoken = Erreur, l'émetteur de token matériel ne peut émettre le type de token pour l'utilisateur {0}. Moidifier le type de token ou l'émetteur de token pour l'utilisateur
hardtoken.addedtoken = Nouveau token matériel ajouté avec le numéro de série {0}
hardtoken.tokenexists = Le token matériel avec le numéro de série {0} existe déjà 
hardtoken.changedtoken = Token matériel avec le numéro de série {0} modifié
hardtoken.errorchangetoken = Erreur pendant la modification du token matériel avec le numéro de série {0}
hardtoken.removedtoken = Token matériel avec le numéro de série {0} supprimé
hardtoken.errorremovetoken = Erreur pendant la suppression du token matériel avec le numéro de série {0}
hardtoken.viewedtoken = Token matériel avec le numéro de série {0} consulté
hardtoken.addedtokencertmapping = Certificate mapping added, certificatesn: {0}, tokensn: {1}.
hardtoken.erroraddtokencertmapping = Error adding certificate mapping, certificatesn: {0}, tokensn: {1}.
hardtoken.removedtokencertmappingcert = Certificate mapping removed, certificatesn: {0}.
hardtoken.errorremovetokencertmappingcert = Error removing certificate mapping, certificatesn: {0}.
hardtoken.removedtokencertmappingtoken = Certificate mapping removed, certificatesn: {0}.
hardtoken.errorremovetokencertmappingtoken = Error removing certificate mapping, certificatesn: {0}.
hardtoken.generatedtoken = Token matériel avec le numéro de série {0} correctement crée
hardtoken.errorgeneratetoken = Erreur pendant la création du token matériel avec le numéro de série {0}

keyrecovery.addedforapproval = La demande de recouvrement de clé est en attente d'approbation
keyrecovery.addeddata = Données ajoutées pour le recouvrement de la clé du certificat avec le numéro de série {0} et l'émetteur {1}
# FIXME keyrecovery.addeddata = Keyrecovery data for certificate with serial number {0}, issuer {1} added.
keyrecovery.erroradddata = Error when trying to add keyrecovery data for certificate with serial number {0}, issuer {1}.
keyrecovery.changeddata = Keyrecovery data for certificate with serial number {0}, issuer {1} changed.
keyrecovery.errorchangedata = Error when trying to update keyrecovery data for certificate with serial number {0}, issuer {1}. 
keyrecovery.removeddata = Keyrecovery data for certificate with serial number {0}, issuer {1} removed.
keyrecovery.errorremovedata = Error when trying to remove keyrecovery data for certificate with serial number {0}, issuer {1}. 
keyrecovery.removeduser = All keyrecovery data for user {0} removed.
keyrecovery.errorremoveuser = Error when removing all keyrecovery data for user {0}.
keyrecovery.sentdata = Keydata for user {0} have been sent for key recovery.
keyrecovery.errorsenddata = Error trying to recover keydata for user {0}.
keyrecovery.markeduser = User {0} newest certificate marked for recovery.
keyrecovery.errormarkuser = Error when trying to mark user {0} newest certificate for recovery.
keyrecovery.markedcert = Certificate with serialNo {0}, issuer {1} marked for recovery.
keyrecovery.errormarkcert = Error when trying to mark certificate with serialNo {0}, issuer {1} for recovery.

# FIXME log.errormissingentry = ERROR MISSING LOG ENTRY: DuplicateKeyException during log, missing log entry.
log.errormissingentry = ENTREE DE LOG MANQUANT : Erreur pendant l'enregistrement
log.errorcreateconf = Erreur pendant la création de la configuration des logs pour l'AC {1}
log.createconf = Impossible de trouver la configuration des logs pendant l'enregistrement de l'AC {1}, création d'une nouvelle configuration

protect.errorcreatesession = ERREUR DE PROTECTION : Ne peux pas créer TableProtectSession:
protect.rowexistsupdate = INFO DE PROTECTION: protection row for entry type: {0}, with key: {1} already exists, updating.
protect.errorcreate = ERREUR DE PROTECTION: can not create protection row for entry type: {0}, with key: {1}.
protect.errorverify = ERREUR DE PROTECTION: verify failed for entry type: {0}, with key: {1}.
protect.errorverifynokey = ERREUR DE PROTECTION: verify failed for entry type: {0}, with key: {1}. No key exists.
protect.errorverifyalg = ERREUR DE PROTECTION: verify failed for entry type: {0}, with key: {1}. Incompatible algorithm.
protect.errorverifywronghash = ERREUR DE PROTECTION: wrong hash for entry type: {0}, with key: {1}.
protect.errorverifynorow = ERREUR DE PROTECTION: can not find protection row for entry type: {0}, with key: {1}.
protect.errorverifycant = ERREUR DE PROTECTION: can not verify protection row for entry type: {0}, with key: {1}.

ra.adminprefadded = Préférence de l'administrateur avec l'id  {0} ajouté
ra.changedadminpref = Préférence de l'administrateur avec la clef {0} modifié.
ra.adminprefexists = Tentative d'ajouter des préférences pour administrateur qui existe déjà.
ra.adminprefnotfound = Préférence de l'administrateur avec la clef {0 n'a pas été trouvé dans la base de données.
ra.defaultadminprefsaved = préférence administrateur par défaut modifiée.
ra.errorsavedefaultadminpref = erreur de sauvegarde des préférences administrateur par défaut.
ra.addedprofile = profil d'entité finale {0} ajouté.
ra.erroraddprofile = Erreuur lors de l'ajout du profil d'entité finale {0}.
ra.clonedprofile =  Ajout d'un nouveau profil d'entité finale {0} profil utilisé {1} comme template.
ra.errorcloneprofile = Erreur lors de l'ajout d'un nouveau profil d'entité finale {0} profil utilisé  {1} comme template.
ra.removedprofile = profil d'entité finale {0} supprimé.
ra.errorremoveprofile = Erreur lors de la suppression du profil d'entité finale {0}.
ra.renamedprofile = profil d'entité finale {0} renommer en {1}.
ra.errorrenameprofile = Erreur pour renommer le profil d'entité finale {0} en {1}.
ra.changedprofile = profil d'entité finale {0} édité.
ra.errorchangeprofile = Erreur lors de l'édition du profil d'entité finale {0}.
ra.savedconf = Sauvegarde de la configuration globale avec l'id {0}.
ra.createdconf = configuration globale avec l'id {0} créée.
ra.errorcreateconf = la création de la configuration globale a échoué
ra.errorgetids = Erreur d'obtention des identifiants de profil d'entité autorisée
ra.errorreadprofiles = Erreur de lecteur des profils d'entités

ra.errorfullfillprofile = Userdata did not fullfill pas de profil end entity profile {0}, dn '{1}: {2}.
ra.errorauthprofile = L'administrateur non autorisé pour accéder au profil d'entité {0}.
ra.errorauthca = L'administrateur non autorisé pour accéder aux AC {0}.
ra.errorcertnoadmin = Votre certificat n'appartient pas à un administrateur. Emmeteur {0}, Numéro de série {1}.
ra.errorcertnouser = Votre certificat n'appartient à aucun utilisateur. Emmeteur {0}, Numéro de série {1}.
ra.errorprint = Erreur en d'impression des données utilisateurs pour l'utilisateur {0}, message: {1}.
ra.approvalad = une action d'entité finale a été ajoutée pour approbation par administrateurs autorisés.
ra.approvaledit = une action d'entité finale a été ajoutée pour approbation par administrateurs autorisés.
ra.addedentity = Entité finale ajoutée {0}.
ra.errorentityexist = l'entité {0} existe déjà.
ra.errorentitynotexist = L'entité {0} n'existe pas.
ra.erroraddentity = Erreur lors de l'ajout d'une entité finale.
ra.editedentitystatus = Éditer entité finale {0}, nouveau statut {1}.
ra.editedentity = Édition de l'entité finale {0}.
ra.erroreditentity = Erreur d'édition de l'entité finale {0}.
ra.removedentity = Suppression de l'entité finale {0}.
ra.errorremoveentity = Erreur de suppression de l'entité finale {0}.
ra.editpwdentity = Mot de passe modifié pour l'entité finale {0}.
ra.revokedentity = Entité finale révoquée {0}.
ra.revokedentitycert = certifiat d'entité finale révoqué. Émetteur {0}, numéro de série {1}.
ra.errorunrevokenotonhold = Non autorisé de  pour non révoquer un certificat qui n'est pas en attente Not allowed to unrevoke a certificate that is not on hold. Issuer {0}, serialNo {1}.
ra.errornotificationnoemail = La notification ne peut pas être adressée à l'utilisateur {0} où le champ d'email est nul.
ra.sentnotification = Notification à l'utilisateur {0} par l'email {1} adressé avec succès.
ra.errorsendnotification = Erreur lors de l'envoi de la notification à l'utilisateur {0} avec l'email {1}.
ra.extendedinfoupgrade = Mise à jour des informations étendues avec la version {0}.
ra.eeprofileupgrade = Mise à jour du profil d'entité avec la version {0}.
ra.eeprofileaddfield = Ajout d'un nouveau champ, {0}, to NUMBERARRAY.
ra.eeprofilenonimpl = isFieldImplemented appel reçu pour un champ non implémenté: {0}.

userdatasource.fetcheduserdatasource = Userdata fetched from user data source {0} successfully.
userdatasource.errorfetchuserdatasource = Error fetching from user data source {0}.
userdatasource.erroruserdatasourceexist = User data source with id {0} does not exist.
userdatasource.errornotauth = Error, not authorized to user data source {0}.
userdatasource.errorfindingall = Error looking for all user data sources.
userdatasource.testedcon = Successfully tested the connection with user data source {0}. 
userdatasource.errortestcon = Error when testing the connection with user data source {0}.
userdatasource.errortestconauth = Error, not authorized to test user data source {0}.
userdatasource.addedsource = User data source {0} added.
userdatasource.erroraddsource = Error adding user data source {0}.
userdatasource.changedsource = User data source {0} changed.
userdatasource.errorchangesource = Error changing user data source {0}.
userdatasource.clonedsource = Added user data source {0} using user data source {1} as template.
userdatasource.errorclonesource = Error adding user data source {0} using user data source {1} as template.
userdatasource.removedsource = Source de donnée utilisateur {0} supprimée
userdatasource.errorremovesource = Erreur pendant la suppression de la source de donnée utilisateur {0}
userdatasource.renamedsource = Source de donnée utilisateur {0} renommée en {1}
userdatasource.errorrenamesource = Pendant la modification du nom de la source de donnée {0} en {1}


sernogenerator.discarding = Discarding serial number out of range.

ocspcaservice.upgrade = Mise à jour OCSPCAService avec la version {0}.

catoken.deactivate = désactivation du TOKEN d'AC.
catoken.inforegisterclasspath = Ne peux pas enregistrer {0}. Habituellement, ce n'est pas une erreur
catoken.classnotfound = Classe non trouvée: {0}.
catoken.errorinstansiate = ne peux pas instancier {0}. {1}.
catoken.upgradesoft = Mise à jour du softCAToken avec la version {0}.

certprofile.upgrade = Mise à jour du profil de certificat avec la version {0}.

publisher.upgrade = Mise à jour de service de publication LDAP avec la version {0}.
publisher.entryexists = Duplication des données, mise à jour.
publisher.noentry = 	Aucune ancienne donnée n'existe pour {0}.
publisher.infoexists = Une donnée avec le DN '{0}' existe.
publisher.errorextocsppubl = ERREUR OCSP EXTERNE, le service de publication ne fonctionne pas pour {0}.
publisher.notpublrevoked = pas de publication de certificat révoqué, statut={0}.
publisher.notpubltype = Le certificat de type '{0}' ne sera pas publié.
publisher.errorldapdecode = LDAP ERREUR: Erreur de décodage {0}.
publisher.errorldapencodestore = LDAP ERREUR: Erreur d'encodage {0} lors du stockage LDAP
publisher.ldapadd = LDAP {0}: Objet: {1} ajouté avec succès.
publisher.ldapmodify = LDAP {0}: objet: {1} modifié avec succès.
publisher.ldapremove = REVOCATION LDAP: Certificat supprimé de l'objet: {0}  avec succès
publisher.errorldapstore = LDAP ERREUR: Erreur de stockage {0} ({1}) dans l'annuaire LDAP ({2}) pour le DN ({3}).
publisher.errorldapremove = LDAP ERREUR: Erreur lors de la suppression du certificat dans l'annuaire LDAP ({0}).
publisher.errorpassword = LDAP ERREUR: Ne peux pas décoder le mot de passe pour la session LDAP: {0}.
publisher.errordisconnect = LDAP ERROR: LdapPublisher: La déconnexion à l'annuaire LDAP a échoué.
publisher.errorrevokenoentry = LDAP ERREUR: Entry holding certificate doesn't exist in LDAP.
publisher.inforevokenocert = Tentative de suppression du certificat dans l'annuaire LDAP, mais il n'y a pas d'attribut pour ce type de certificat.
publisher.errorldapbind = LDAP ERROR: Erreur de connexion à l'annuaire LDAP. {0}
publisher.errornobinddn = LDAP ERREUR: ne trouve pas de bindDN.

cmp.errorunknownprotalg = Received CMP message with unknown protection alg: {0}.
cmp.errorcertconfirmstatus = Received a Cert Confirm with status {0}.
cmp.receivedmsg = CMP message received from: {0}.
cmp.sentresponsemsg = Sent a CMP response to: {0}.
cmp.receivedrevreq = Received a revocation request for issuer: {0} and serno: {1}.
cmp.receivedrevreqnoissuer = Received a revocation request missing issuer or serno.
cmp.errornullresp = CMP message dispatcher returned a null response.
cmp.errortcptoolongmsg = Received a message of length {0}, which is way too much to be sane.
cmp.errortcpwronglen = Received a message of length {0}, that claimed to contain {1} bytes.
cmp.erroradduserupdate = Could not add user '{0}', although it did not exists a blink of an eye ago! Will update instead.
cmp.erroradduser = Error adding user '{0}'.
cmp.errorgeneral = Error during CMP processing.
cmp.errorauthmessage = Authentication failed for message.
cmp.errorcalcprotection = Error calculating protection.
cmp.errorunauthmessagera = Recevied an unathenticated message in RA mode.
cmp.infonouserfordn = Did not find a username matching dn: {0}.
cmp.errornocmrfreq = ICmpMessage is not a CrmfRequestMessage.
cmp.errornullresp = Response from signSession is null.
cmp.receivedrevreq = Received a revocation request for issuer: {0} and serno: {1}.
cmp.errornotauthrevoke = Not authorized to revoke certificate for the user with issuer: {0} and serno: {1}.
cmp.errorcertnofound = Certificate not found for issuer: {0} and serno: {1}.
cmp.errormissingissuerrevoke = Received a revocation request missing issuer or serno.
cmp.errorrevoke = Erreur durant la révocation du certificat.
cmp.errornoprot = No PKI protection to verify.


ocsp.receivedunidreq = Demande reçu  (ip;fqdn): {0}; {1} pour Fnr correspondant à Unid={2}.
ocsp.errordatabaseunid = A reçu une erreur de base de données en recherchant le databasource pour Unid-Fnr
ocsp.errorunidnosnindn = N'a pas trouvé un numéro de série dans le DN: {0}.
ocsp.errorunidnosnmapping = Aucune correspondance de Fnr n'existe pour UNID: {0}.
ocsp.returnedunidresponse = Réponse retournée à  (ip;fqdn): {0}; {1} avec Fnr={2} pour Unid={3}.
ocsp.errornoclientauth = Requête reçue sans authentification client de (ip;fqdn): {0};{1}.
ocsp.errorverifycert = Erreur en essayant de vérifier le certificat de client.
ocsp.erroruntrustedclientauth = Requête reçue avec un certificat client de (ip;fqdn): {0};{1}.
ocsp.errornoinitparam = {0} init-parameter doit être positionné
ocsp.errornotrustfiles = Pas de fichier dans le répertoire trustDir: {0}.
ocsp.errorreadingtrustfiles = Erreur de lecture du fichier de trustDir: {0}.
ocsp.errorreadingfile = Erreur de lecture {0} depuis {1}: {2}.
ocsp.certcollectionempty = La collection de certificats adressée est vide.
ocsp.errorcomparehash = OCSPexception durant la comparaison de l'empreinte du certificat, contourné cacert pour '{0}'.
ocsp.nomatchingcacert = Ne trouve pas le certificat d'AC correspondant au DN : {0}.
ocsp.reloadkeys = Rechargement de la clef due à une requête provenant de {0}.
ocsp.errorunsignedreq = Requête OCSP non signée. Servlet impose la signature.
ocsp.errorinvalidsignature = 	La signature des requêtes OCSP (OCSPRequest)est invalide.
ocsp.errornoreqentities = La demande d'OCSP ne contient aucune entité simpleRequest.
ocsp.errorgencerthash = mpossible de générer l'empreinte du certificat d'AC
ocsp.errorfindcacert = Impossible de trouver le certificat par le biais de l'empreinte de l'émetteur: {0}, ou le répondeur de défaut : {1}.
ocsp.errorfindcacertusedefault = Impossible de trouver le certificat par le biais de l'empreinte de l'émetteur: {0}, utilise le répondeur par défaut pour envoyer « UnknownStatus ».
ocsp.errorprocessextension = Une erreur s'est produite durant le traitement de la classe OCSP : {0}, code d'erreur={1}.
ocsp.errornocacreateresp = Impossible de trouver le certificat et la clef d'AC pour produire la réponse d'OCSP.
ocsp.errorprocessreq = Erreur du processus de requête OCSP .
ocsp.classnotfound = La classe {0} ne peut-être chargée.
ocsp.nocardpwd = Pas de mot de passe de carte spécifié. 
ocsp.nohwsigningclass = Pas de classe de signature HW OCSP défini.
ocsp.errornovalidkeys = Pas de clef valide spécifiée.
ocsp.errorinitialize = Incapable d'initialiser OCSPServlet.
ocsp.signcertnotindb = SCertificat de signature avec le numéro de série {0} de l'émetteur {1} ne peut pas être trouvé dans la base de données (la signature et le certificat d'AC doivent être publiés dans le répondeur d'OCSP ).
ocsp.signcertrevoked = Certificat de signature avec le numéro de série {0} de l'émetteur {1} est révoqué.
ocsp.signcerthasnochain = Certificat de signature avec le numéro de série  {0} de l'émetteur {1} n'a pas la chaîne de l'AC racine. 
ocsp.errorgetalias = Impossible d'obtenir l'alias {0} dans le fichier {1}.
ocsp.newsigningkey = Nouvelle clef de signature d'OCSP pour l'AC '{0}'. clef cert '{1}'.
ocsp.errorocspkeynotusable = 	Clef de signature d'OCSP non utilisable pour l'AC  '{0}'. clef de certificat avec le numéro de série: {1}.
ocsp.errorloadsigningcerts = impossible de charger les certificats de signature. 

scep.errormissingparam = Requête reçue avec des paramètres manquants de {0}. Les paramètres 'opération' et 'message' doivent être fourni. 
scep.receivedmsg = Recu un message SCEP de {0}.
scep.sentresponsemsg = envoyer une SCEP {0} réponse de {1}.
scep.errorunknownca = SCEP {0} requête pour une AC inconnue '{1}'.
scep.errorinvalidreq = requête vide ou invalide reçu.
scep.errorauth = Autorisation refusée
scep.errorclientstatus = Mauvais statut client
scep.errorgeneral = Erreur durant le processus de requête SCEP.

batch.createkeystore = Keystore créé pour '{0}'.
batch.errornokeyrecoverydata = Pas de données de clef de recouvrement disponible pour cet utilisateur '{0}', ne peut pas être généré
batch.retrieveingkeys = Récupération de clef pour {0}.
batch.generatingkeys = Génération de clef pour {0}.
batch.generateduser = Nouvel utilisateur généré avec succès - {0}.
batch.generatingallstatus = Génére tout {0}.
batch.generatingnoofusers = Génération du Batch {0} utilisateur.
batch.errorsetstatus = Une erreur s'est produite, plaçant le statut à {0}.
batch.infonoclearpwd = l'utilisateur '{0}' n'a pas le mot de passe en clair.
batch.errorbatchfailed = BatchMakeP12 a échoué pour  {0} utilisateurs ({1} réussi) - {0}.
batch.errorbatchfaileduser = BatchMakeP12 a échoué pour '{0}'.
batch.success = {0} les nouveaux utilisateurs ont générés avec succès  - {1}.
batch.generateindir = Génération des clefs dans le répertoire {0}.
batch.errorunknown = Utilisateur inconnu, or le mot de passe ne clair est nulle: {0}.
batch.errorrootnotverify = 	Le certificat de RootCA n'est pas vérifié.
batch.errorrootnotselfsigned = Le certificat de RootCA n'est pas auto-signé.
batch.errorgennotverify = Le certificat produit n'est pas vérifié pas en utilisant le certificat d'AC

certreq.sentlatestcertreq = Envoi dernière requête certificat au client à  {0}. 
certreq.errorsendlatestcertreq = Erreur durant l'envoi de la requête de certificat à {0}.
certreq.errorsendcert = Erreur durant le processus d'envoi du certificat à {0}, cause: {1}.
certreq.sentlatestcrl = Envoi dernière CRL au client à {0}.
certreq.errorsendcrl = Erreur durant l'envoi de la CRL à {0}, cause: {1}.
certreq.receivedcertreq = Réception d'une requête de certificat pour l'utilisateur '{0}' depuis {1}

healthcheck.allipsauthorized = Toutes les adresses IP sont autorisées
healthcheck.errorauth = Erreur : le composant Healthcheck a reçu une requête depuis une IP ({0}) non autorisée 

startservice.shutdown = Suppression, EJBCA éteint
startservice.startup = Initialisation, EJBCA en cours de démarrage

# Messages used by the log system itself
log.nouserinvolved = Aucune entité impacté
log.nocertinvolved = Pas de certificat impacté
log.adminnotknown = Administrateur inconnu

error.catokenoffline = Le token CA {0} est hors ligne
error.unknown = Erreur inconnue

APADDENDENTITY            = Ajouter entité finale

APCHANGESTATUSENDENTITY   = changer le statut de l'entité finale

APEDITENDENTITY           = Edition d'une entité finale

APKEYRECOVERY             = Recouvrement de clé

CLITOOL                   = Utilitaire en ligne de commande
