/*************************************************************************
 *                                                                       *
 *  EJBCA: The OpenSource Certificate Authority                          *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
 
package org.ejbca.ui.web.pub;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Enumeration;

import javax.ejb.ObjectNotFoundException;
import javax.naming.InitialContext;
import javax.rmi.PortableRemoteObject;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.ejbca.core.ejb.ca.auth.IAuthenticationSessionHome;
import org.ejbca.core.ejb.ca.auth.IAuthenticationSessionRemote;
import org.ejbca.core.ejb.ca.caadmin.ICAAdminSessionHome;
import org.ejbca.core.ejb.ca.caadmin.ICAAdminSessionRemote;
import org.ejbca.core.ejb.ca.sign.ISignSessionHome;
import org.ejbca.core.ejb.ca.sign.ISignSessionRemote;
import org.ejbca.core.ejb.keyrecovery.IKeyRecoverySessionHome;
import org.ejbca.core.ejb.keyrecovery.IKeyRecoverySessionRemote;
import org.ejbca.core.ejb.ra.IUserAdminSessionHome;
import org.ejbca.core.ejb.ra.IUserAdminSessionRemote;
import org.ejbca.core.ejb.ra.raadmin.IRaAdminSessionHome;
import org.ejbca.core.ejb.ra.raadmin.IRaAdminSessionRemote;
import org.ejbca.core.model.SecConst;
import org.ejbca.core.model.ca.AuthLoginException;
import org.ejbca.core.model.ca.AuthStatusException;
import org.ejbca.core.model.ca.SignRequestException;
import org.ejbca.core.model.ca.SignRequestSignatureException;
import org.ejbca.core.model.ca.catoken.CATokenConstants;
import org.ejbca.core.model.keyrecovery.KeyRecoveryData;
import org.ejbca.core.model.log.Admin;
import org.ejbca.core.model.ra.UserDataConstants;
import org.ejbca.core.model.ra.UserDataVO;
import org.ejbca.core.model.ra.raadmin.EndEntityProfile;
import org.ejbca.ui.web.RequestHelper;
import org.ejbca.util.Base64;
import org.ejbca.util.CertTools;
import org.ejbca.util.KeyTools;




/**
 * Servlet used to install a private key with a corresponding certificate in a browser. A new
 * certificate is installed in the browser in following steps:<br>
 * 1. The key pair is generated by the browser. <br>
 * 2. The public part is sent to the servlet in a POST together with user info ("pkcs10|keygen",
 * "inst", "user", "password"). For internet explorer the public key is sent as a PKCS10
 * certificate request. <br>
 * 3. The new certificate is created by calling the RSASignSession session bean. <br>
 * 4. A page containing the new certificate and a script that installs it is returned to the
 * browser. <br>
 * 
 * <p></p>
 * 
 * <p>
 * The following initiation parameters are needed by this servlet: <br>
 * "responseTemplate" file that defines the response to the user (IE). It should have one line
 * with the text "cert =". This line is replaced with the new certificate. "keyStorePass".
 * Password needed to load the key-store. If this parameter is none existing it is assumed that no
 * password is needed. The path could be absolute or relative.<br>
 * </p>
 *
 * @author Original code by Lars Silv?n
 * @version $Id: CertReqServlet.java,v 1.11 2006-11-24 12:09:56 anatom Exp $
 */
public class CertReqServlet extends HttpServlet {
    private static Logger log = Logger.getLogger(CertReqServlet.class);
    private ISignSessionHome signsessionhome = null;
    private IUserAdminSessionHome useradminhome = null;
    private IRaAdminSessionHome raadminhome = null;
    private IKeyRecoverySessionHome keyrecoveryhome = null;
	private ICAAdminSessionHome caadminhome = null;
	private IAuthenticationSessionHome authhome = null;
    private byte[] bagattributes = "Bag Attributes\n".getBytes();
    private byte[] friendlyname = "    friendlyName: ".getBytes();
    private byte[] subject = "subject=/".getBytes();
    private byte[] issuer = "issuer=/".getBytes();
    private byte[] beginCertificate = "-----BEGIN CERTIFICATE-----".getBytes();
    private byte[] endCertificate = "-----END CERTIFICATE-----".getBytes();
    private byte[] beginPrivateKey = "-----BEGIN PRIVATE KEY-----".getBytes();
    private byte[] endPrivateKey = "-----END PRIVATE KEY-----".getBytes();
    private byte[] NL = "\n".getBytes();


    /**
     * Servlet init
     *
     * @param config servlet configuration
     *
     * @throws ServletException on error
     */
    public void init(ServletConfig config) throws ServletException {
        super.init(config);

        try {
            // Install BouncyCastle provider
            CertTools.installBCProvider();

            // Get EJB context and home interfaces
            InitialContext ctx = new InitialContext();
            signsessionhome = (ISignSessionHome) PortableRemoteObject.narrow(
                      ctx.lookup("RSASignSession"), ISignSessionHome.class );
            useradminhome = (IUserAdminSessionHome) PortableRemoteObject.narrow(
                             ctx.lookup("UserAdminSession"), IUserAdminSessionHome.class );
            raadminhome   = (IRaAdminSessionHome) PortableRemoteObject.narrow(
                             ctx.lookup("RaAdminSession"), IRaAdminSessionHome.class );            
            keyrecoveryhome = (IKeyRecoverySessionHome) PortableRemoteObject.narrow(
                             ctx.lookup("KeyRecoverySession"), IKeyRecoverySessionHome.class );
            
            caadminhome = (ICAAdminSessionHome) javax.rmi.PortableRemoteObject.narrow(ctx.lookup("CAAdminSession"), ICAAdminSessionHome.class);
            
            authhome = (IAuthenticationSessionHome) javax.rmi.PortableRemoteObject.narrow(ctx.lookup("AuthenticationSession"), IAuthenticationSessionHome.class);
        } catch( Exception e ) {
            throw new ServletException(e);
        }
    }

    /**
     * Handles HTTP POST
     *
     * @param request servlet request
     * @param response servlet response
     *
     * @throws IOException input/output error
     * @throws ServletException on error
     */
    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws IOException, ServletException {
        ServletDebug debug = new ServletDebug(request, response);
        boolean usekeyrecovery = false;

        RequestHelper.setDefaultCharacterEncoding(request);
        try {
            String username = request.getParameter("user");
            String password = request.getParameter("password");
            String keylengthstring = request.getParameter("keylength");
            String keyalgstring = request.getParameter("keyalg");
            String openvpn = request.getParameter("openvpn");
			String keylength = "1024";
			String keyalg = CATokenConstants.KEYALGORITHM_RSA;
			
            int resulttype = 0;
            if(request.getParameter("resulttype") != null)
              resulttype = Integer.parseInt(request.getParameter("resulttype")); // Indicates if certificate or PKCS7 should be returned on manual PKCS10 request.
            

            String classid = "clsid:127698e4-e730-4e5c-a2b1-21490a70c8a1\" CODEBASE=\"/CertControl/xenroll.cab#Version=5,131,3659,0";

            if ((request.getParameter("classid") != null) &&
                    !request.getParameter("classid").equals("")) {
                classid = request.getParameter("classid");
            }

            if (keylengthstring != null) {
                keylength = keylengthstring;
            }
            if (keyalgstring != null) {
                keyalg = keyalgstring;
            }

            Admin administrator = new Admin(Admin.TYPE_PUBLIC_WEB_USER, request.getRemoteAddr());

            IUserAdminSessionRemote adminsession = useradminhome.create();
            IRaAdminSessionRemote raadminsession = raadminhome.create();            
            ISignSessionRemote signsession = signsessionhome.create();
            RequestHelper helper = new RequestHelper(administrator, debug);

            log.info("Received certificate request for user " + username + " from "+request.getRemoteAddr());
            debug.print("<h3>username: " + username + "</h3>");

            // Check user
            int tokentype = SecConst.TOKEN_SOFT_BROWSERGEN;

            usekeyrecovery = (raadminsession.loadGlobalConfiguration(administrator)).getEnableKeyRecovery();

            UserDataVO data = adminsession.findUser(administrator, username);

            if (data == null) {
                throw new ObjectNotFoundException();
            }

            boolean savekeys = data.getKeyRecoverable() && usekeyrecovery &&  (data.getStatus() != UserDataConstants.STATUS_KEYRECOVERY);
            boolean loadkeys = (data.getStatus() == UserDataConstants.STATUS_KEYRECOVERY) &&
                usekeyrecovery;

            // get users Token Type.
            tokentype = data.getTokenType();
            if(tokentype == SecConst.TOKEN_SOFT_P12){
              KeyStore ks = generateToken(administrator, username, password, data.getCAId(), keylength, keyalg, false, loadkeys, savekeys, data.getEndEntityProfileId());
              if (StringUtils.equals(openvpn, "on")) {            	  
                  sendOpenVPNToken(ks, username, password, response);
              }
              sendP12Token(ks, username, password, response);
            }
            if(tokentype == SecConst.TOKEN_SOFT_JKS){
              KeyStore ks = generateToken(administrator, username, password, data.getCAId(), keylength, keyalg, true, loadkeys, savekeys, data.getEndEntityProfileId());
              sendJKSToken(ks, username, password, response);
            }
            if(tokentype == SecConst.TOKEN_SOFT_PEM){
              KeyStore ks = generateToken(administrator, username, password, data.getCAId(), keylength, keyalg, false, loadkeys, savekeys, data.getEndEntityProfileId());
              sendPEMTokens(ks, username, password, response);
            }
            if(tokentype == SecConst.TOKEN_SOFT_BROWSERGEN){

              // first check if it is a netcsape request,
              if (request.getParameter("keygen") != null) {
                  byte[] reqBytes=request.getParameter("keygen").getBytes();
                  log.debug("Received NS request:"+new String(reqBytes));
                  if (reqBytes != null) {
                      byte[] certs = helper.nsCertRequest(signsession, reqBytes, username, password);
                      RequestHelper.sendNewCertToNSClient(certs, response);
                  }
              } else if ( (request.getParameter("pkcs10") != null) || (request.getParameter("PKCS10") != null) ) {
                  // if not netscape, check if it's IE
                  byte[] reqBytes=request.getParameter("pkcs10").getBytes();
                  if (reqBytes == null)
                      reqBytes=request.getParameter("PKCS10").getBytes();
                  log.debug("Received IE request:"+new String(reqBytes));
                  if (reqBytes != null) {
                      byte[] b64cert=helper.pkcs10CertRequest(signsession, reqBytes, username, password, RequestHelper.ENCODED_PKCS7);
                      debug.ieCertFix(b64cert);
                      RequestHelper.sendNewCertToIEClient(b64cert, response.getOutputStream(), getServletContext(), getInitParameter("responseTemplate"),classid);
                  }
              } else if (request.getParameter("pkcs10req") != null && resulttype != 0) {
                  // if not IE, check if it's manual request
                  byte[] reqBytes=request.getParameter("pkcs10req").getBytes();
                  if (reqBytes != null) {
                      byte[] b64cert=helper.pkcs10CertRequest(signsession, reqBytes, username, password, resulttype);
                      if(resulttype == RequestHelper.ENCODED_PKCS7)  
                        RequestHelper.sendNewB64Cert(b64cert, response, RequestHelper.BEGIN_PKCS7_WITH_NL, RequestHelper.END_PKCS7_WITH_NL);
                      if(resulttype == RequestHelper.ENCODED_CERTIFICATE)
                        RequestHelper.sendNewB64Cert(b64cert, response, RequestHelper.BEGIN_CERTIFICATE_WITH_NL, RequestHelper.END_CERTIFICATE_WITH_NL);
                  }
              }
            }
        } catch (ObjectNotFoundException oe) {
            log.debug("Non existent username!");
            debug.printMessage("Non existent username!");
            debug.printMessage(
                "To generate a certificate a valid username and password must be entered.");
            debug.printDebugInfo();
            return;
        } catch (AuthStatusException ase) {
            log.debug("Wrong user status!");
            debug.printMessage("Wrong user status!");
            if (usekeyrecovery) {
                debug.printMessage(
                    "To generate a certificate for a user the user must have status new, failed or inprocess.");
            } else {
                debug.printMessage(
                    "To generate a certificate for a user the user must have status new, failed or inprocess.");
            }
            debug.printDebugInfo();
            return;
        } catch (AuthLoginException ale) {
            log.debug("Wrong password for user!");
            debug.printMessage("Wrong username or password!");
            debug.printMessage(
                "To generate a certificate a valid username and password must be entered.");
            debug.printDebugInfo();
            return;
        } catch (SignRequestException re) {
            log.debug("Invalid request!");
            debug.printMessage("Invalid request!");
            debug.printMessage("Please supply a correct request.");
            debug.printDebugInfo();
            return;
        } catch (SignRequestSignatureException se) {
            log.error("Invalid signature on certificate request:", se);
            debug.printMessage("Invalid signature on certificate request!");
            debug.printMessage("Please supply a correctly signed request.");
            debug.printDebugInfo();
            return;
        } catch (java.lang.ArrayIndexOutOfBoundsException ae) {
            log.debug("Empty or invalid request received.");
            debug.printMessage("Empty or invalid request!");
            debug.printMessage("Please supply a correct request.");
            debug.printDebugInfo();
            return;
        } catch (org.ejbca.core.model.ca.IllegalKeyException e) {
            log.debug("Illegal Key received: "+e.getMessage());
            debug.printMessage("Invalid Key in request: "+e.getMessage());
            debug.printMessage("Please supply a correct request.");
            debug.printDebugInfo();
            return;
        } catch (Exception e) {
            log.debug(e);
            debug.print("<h3>parameter name and values: </h3>");
            Enumeration paramNames = request.getParameterNames();
            while (paramNames.hasMoreElements()) {
                String name = paramNames.nextElement().toString();
                String parameter = request.getParameter(name);
                debug.print("<h4>" + name + ":</h4>" + parameter + "<br>");
            }
            debug.takeCareOfException(e);
            debug.printDebugInfo();
        }
    }

    //doPost

    /**
     * Handles HTTP GET
     *
     * @param request servlet request
     * @param response servlet response
     *
     * @throws IOException input/output error
     * @throws ServletException on error
     */
    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws IOException, ServletException {
        log.debug(">doGet()");
        response.setHeader("Allow", "POST");

        ServletDebug debug = new ServletDebug(request, response);
        debug.print("The certificate request servlet only handles POST method.");
        debug.printDebugInfo();
        log.debug("<doGet()");
    }

    // doGet
    /**
     * method to create an install package for OpenVPN including keys and send to user.
     * Contributed by: Jon Bendtsen, jon.bendtsen(at)laerdal.dk
     */
    private void sendOpenVPNToken(KeyStore ks, String username, String kspassword, HttpServletResponse out) throws Exception {
    	ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    	ks.store(buffer, kspassword.toCharArray());
    	
    	File fout = new File("/usr/local/tmp/" + username + ".p12");
    	FileOutputStream certfile = new FileOutputStream(fout);
    	
    	Enumeration en = ks.aliases();
    	String alias = (String)en.nextElement();
    	// Then get the certificates
    	Certificate[] certs = KeyTools.getCertChain(ks, alias);
    	// The first  one (certs[0]) is the users cert and the last
    	// one (certs [certs.lenght-1]) is the CA-cert
    	X509Certificate x509cert = (X509Certificate) certs[0];
    	String IssuerDN = x509cert.getIssuerDN().toString();
    	String SubjectDN = x509cert.getSubjectDN().toString();
    	
    	// export the users certificate to file
    	buffer.writeTo(certfile);
    	buffer.flush();
    	buffer.close();
    	certfile.close();
    	
    	// run shell script, which will also remove the created files
    	// parameters are the username, IssuerDN and SubjectDN
    	// IssuerDN and SubjectDN will be used to select the right
    	// openvpn configuration file
    	// they have to be written to stdin of the script to support
    	// spaces in the username, IssuerDN or SubjectDN
    	Runtime rt = Runtime.getRuntime();
    	if (rt==null) {
    		log.error("getRuntime failed. null pointer");
    	} else {
    		Process p = rt.exec("/usr/local/ejbca/bin/mk_openvpn_" + "windows_installer.sh");
    		if (p==null) {
    			log.error("execution of openvpn windows" + " installer script failed. Null pointer");
    		} else {
    			OutputStream pstdin = p.getOutputStream();
    			PrintStream stdoutp = new PrintStream(pstdin);
    			stdoutp.println(username);
    			stdoutp.println(IssuerDN);
    			stdoutp.println(SubjectDN);
    			stdoutp.flush();
    			stdoutp.close();
    			pstdin.close();
    			int exitVal = p.waitFor();
    			if (exitVal != 0) {
        			log.error("Openvpn windows installer script exitValue: " + exitVal);    				
    			} else {
        			log.debug("Openvpn windows installer script exitValue: " + exitVal);    				
    			}
    		}
    	}
    	
    	// we ought to check if the script was okay or not, but in a little
    	// while we will look for the openvpn-gui-install-$username.exe
    	// and fail there if the script failed. Also, one could question
    	// what to do if it did fail, serve the user the certificate?
    	
    	// sending the OpenVPN windows installer
    	String filename = "openvpn-gui-install-" + username + ".exe";
    	File fin =  new File("/usr/local/tmp/" + filename);
    	FileInputStream vpnfile = new FileInputStream(fin);
    	
    	out.setContentType("application/x-msdos-program");
    	out.setHeader("Content-disposition", "filename=" + filename);
    	int filesize=0;
    	byte[] buf = new byte[4096];    	
    	for(;;) {
    		int count = vpnfile.read(buf);
    		if (count == -1) {
    			break;
    		}
    		filesize = count + filesize;
    		// is this too late to set the filesize?
    		out.setContentLength(filesize);
    		out.getOutputStream().write(buf);
    	}
    	vpnfile.close();
    	// delete OpenVPN windows installer, the script will delete cert.
    	fin.delete();
    	out.flushBuffer();    	
    } // sendOpenVPNToken
    
    private void sendP12Token(KeyStore ks, String username, String kspassword,
        HttpServletResponse out) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        ks.store(buffer, kspassword.toCharArray());

        out.setContentType("application/x-pkcs12");
        out.setHeader("Content-disposition", "filename=" + username + ".p12");
        out.setContentLength(buffer.size());
        buffer.writeTo(out.getOutputStream());
        out.flushBuffer();
        buffer.close();
    }

    private void sendJKSToken(KeyStore ks, String username, String kspassword,
        HttpServletResponse out) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        ks.store(buffer, kspassword.toCharArray());

        out.setContentType("application/octet-stream");
        out.setHeader("Content-disposition", "filename=" + username + ".jks");
        out.setContentLength(buffer.size());
        buffer.writeTo(out.getOutputStream());
        out.flushBuffer();
        buffer.close();
    }

    private void sendPEMTokens(KeyStore ks, String username, String kspassword,
        HttpServletResponse out) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        String alias = "";

        // Find the key private key entry in the keystore
        Enumeration e = ks.aliases();
        Object o = null;
        PrivateKey serverPrivKey = null;

        while (e.hasMoreElements()) {
            o = e.nextElement();

            if (o instanceof String) {
                if ((ks.isKeyEntry((String) o)) &&
                        ((serverPrivKey = (PrivateKey) ks.getKey((String) o,
                                kspassword.toCharArray())) != null)) {
                    alias = (String) o;

                    break;
                }
            }
        }

        byte[] privKeyEncoded = "".getBytes();

        if (serverPrivKey != null) {
            privKeyEncoded = serverPrivKey.getEncoded();
        }

        //Certificate chain[] = ks.getCertificateChain((String) o);
        Certificate[] chain = KeyTools.getCertChain(ks, (String) o);
        X509Certificate userX509Certificate = (X509Certificate) chain[0];

        byte[] output = userX509Certificate.getEncoded();
        String sn = CertTools.getSubjectDN(userX509Certificate);

        String subjectdnpem = sn.replace(',', '/');
        String issuerdnpem = CertTools.getIssuerDN(userX509Certificate).replace(',', '/');

        buffer.write(bagattributes);
        buffer.write(friendlyname);
        buffer.write(alias.getBytes());
        buffer.write(NL);
        buffer.write(beginPrivateKey);
        buffer.write(NL);

        byte[] privKey = Base64.encode(privKeyEncoded);
        buffer.write(privKey);
        buffer.write(NL);
        buffer.write(endPrivateKey);
        buffer.write(NL);
        buffer.write(bagattributes);
        buffer.write(friendlyname);
        buffer.write(alias.getBytes());
        buffer.write(NL);
        buffer.write(subject);
        buffer.write(subjectdnpem.getBytes());
        buffer.write(NL);
        buffer.write(issuer);
        buffer.write(issuerdnpem.getBytes());
        buffer.write(NL);
        buffer.write(beginCertificate);
        buffer.write(NL);

        byte[] userCertB64 = Base64.encode(output);
        buffer.write(userCertB64);
        buffer.write(NL);
        buffer.write(endCertificate);
        buffer.write(NL);

        if (CertTools.isSelfSigned(userX509Certificate)) {
        } else {
            for (int num = 1; num < chain.length; num++) {
                X509Certificate tmpX509Cert = (X509Certificate) chain[num];
                sn = CertTools.getSubjectDN(tmpX509Cert);

                String cn = CertTools.getPartFromDN(sn, "CN");
                if (StringUtils.isEmpty(cn)) {
                	cn="Unknown";
                }

                subjectdnpem = sn.replace(',', '/');
                issuerdnpem = CertTools.getIssuerDN(tmpX509Cert).replace(',', '/');

                buffer.write(bagattributes);
                buffer.write(friendlyname);
                buffer.write(cn.getBytes());
                buffer.write(NL);
                buffer.write(subject);
                buffer.write(subjectdnpem.getBytes());
                buffer.write(NL);
                buffer.write(issuer);
                buffer.write(issuerdnpem.getBytes());
                buffer.write(NL);

                byte[] tmpOutput = tmpX509Cert.getEncoded();
                buffer.write(beginCertificate);
                buffer.write(NL);

                byte[] tmpCACertB64 = Base64.encode(tmpOutput);
                buffer.write(tmpCACertB64);
                buffer.write(NL);
                buffer.write(endCertificate);
                buffer.write(NL);
            }
        }

        out.setContentType("application/octet-stream");
        out.setHeader("Content-disposition", " attachment; filename=" + username + ".pem");
        buffer.writeTo(out.getOutputStream());
        out.flushBuffer();
        buffer.close();
    }


    private KeyStore generateToken(Admin administrator, String username, String password, int caid, String keylength, String keyalg, boolean createJKS, 
    		                       boolean loadkeys, boolean savekeys, int endEntityProfileId)
       throws Exception{
    	
    	
         KeyRecoveryData keyData = null;
         KeyPair rsaKeys = null;
         boolean reusecertificate = false;
         if(loadkeys){
        	 
           IRaAdminSessionRemote raadminsession = raadminhome.create();
           EndEntityProfile endEntityProfile = raadminsession.getEndEntityProfile(administrator, endEntityProfileId);
           reusecertificate = endEntityProfile.getReUseKeyRevoceredCertificate();
        	 
           // used saved keys.
           IKeyRecoverySessionRemote keyrecoverysession = keyrecoveryhome.create();
           keyData = keyrecoverysession.keyRecovery(administrator, username, endEntityProfileId);
           rsaKeys = keyData.getKeyPair();
           
           if(reusecertificate){
        	   keyrecoverysession.unmarkUser(administrator,username);
           }
         }
         else{
           // generate new keys.
           rsaKeys = KeyTools.genKeys(keylength, keyalg);
         }
         
         ISignSessionRemote signsession = signsessionhome.create();
         X509Certificate cert = null;
         if(reusecertificate){
        	 cert = (X509Certificate) keyData.getCertificate();
             ICAAdminSessionRemote caadminsession = caadminhome.create();
             boolean finishUser = caadminsession.getCAInfo(administrator,caid).getFinishUser();
             if(finishUser){
           	  IAuthenticationSessionRemote authsession = authhome.create();
           	  authsession.finishUser(administrator, username, password);
             }
        	 
         }else{        	 
             cert = (X509Certificate)signsession.createCertificate(administrator, username, password, rsaKeys.getPublic());	 
         }

        // Make a certificate chain from the certificate and the CA-certificate
        Certificate[] cachain = (Certificate[]) signsession.getCertificateChain(administrator, caid).toArray(new Certificate[0]);

        // Verify CA-certificate
        if (CertTools.isSelfSigned((X509Certificate) cachain[cachain.length - 1])) {
            try {
                cachain[cachain.length - 1].verify(cachain[cachain.length - 1].getPublicKey());
            } catch (GeneralSecurityException se) {
                throw new Exception("RootCA certificate does not verify");
            }
        } else {
            throw new Exception("RootCA certificate not self-signed");
        }

        // Verify that the user-certificate is signed by our CA
        try {
            cert.verify(cachain[0].getPublicKey());
        } catch (GeneralSecurityException se) {
            throw new Exception("Generated certificate does not verify using CA-certificate.");
        }

        if (savekeys) {
            // Save generated keys to database.
            IKeyRecoverySessionRemote keyrecoverysession = keyrecoveryhome.create();
            keyrecoverysession.addKeyRecoveryData(administrator, cert, username, rsaKeys);
        }

        // Use CN if as alias in the keystore, if CN is not present use username
        String alias = CertTools.getPartFromDN(CertTools.getSubjectDN(cert), "CN");
        if (alias == null) alias = username;

        // Store keys and certificates in keystore.
        KeyStore ks = null;

        if (createJKS) {
            ks = KeyTools.createJKS(alias, rsaKeys.getPrivate(), password, cert, cachain);
        } else {
            ks = KeyTools.createP12(alias, rsaKeys.getPrivate(), cert, cachain);
        }

        return ks;
    }
}


// CertReqServlet
