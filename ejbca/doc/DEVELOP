Subject and Issuer DNs
======================
Handling of subject and issuer DNs must be done in an extremely predictable way,
and in the same way everywhere. Issue are ordering of DN elements, handling of
localized strings (UTF8) etc. Because of this, there are a few methods in
se.anatom.ejbca.util.CertTools that MUST be used when handling DNs:

stringToBCDNString() - when handling user input of a DN string to store od
match.
getSubjectDN(cert) - extracts subject DN from a certificate
getIssuerDN(cert) - extracts issuer DN from a certificate
getIssuerDN(crl) - - extracts issuer DN from a CRL

Logging
=======

Straight console output (System.out) MUST not be used in EJBCA except in
cases of console admin utilities.

There are two types of logging in EJBCA:

1. CA logs, defining important events. These logs end up in the database and can
be searched through the administration Web-GUI.

2. Error and debug logs. These logs use Log4j and end up in a log file defined
in JBoss.

CA logs
-------

There are three important classes:
Admin     : Defines the administrator that performed the action.
LogEntry  : Represents a line in the log database. Only the contants defined
here are used.
ILogSessionRemote/Local : The log functionality itself.

To perform logging, one must first aquire the remote interface to the log
session:
obj1 = jndicontext.lookup("LogSession");
LogSessionHome logsessionhome = (ILogSessionHome
javax.rmi.PortableRemoteObject.narrow(obj1, ILogSessionHome.class);
logsession = logsessionhome.create();

Next step is to log trough the function 'log', it's as easy as can be.

Parameters to the log function are:
admin : is of the class Admin and is created according to the following
criteria:
    1. In case a client certificate exists, new Admin(certificate)
    2. In other cases one of the types defined in Admin.TYPE_...
       ex: new Admin(Admin.TYPE_RACOMMANDLINE_USER, ip-adress).
       If possible, the ip-adress should be passed.
module : is one of the LogEntry.MODULE_ constants and defines in which module
the event occured.
    ex : LogEntry.MODULE_CA.
time : the time of the event.
username : describes which user (endentity) that is involved in the event.
null in case no user can be considered to be involved.
certificate : defines which certificate is involved in the event. null in case
no certificate can be considered to be involved.
event : is one of the LogEntry.EVENT_ constants and defines which type of event
occured.
comment : a comment to the event.

If there are events that are not defined it is easy to add new ones, just follow
these steps:
1. Add an EVENT_INFO/ERROR constant to LogEntry
2. Add corresponting text in the constant LogEntry.EVENTNAMES_INFO/ERROR
3. Open the file src/ra/web/raadmin/languages/languagefile.en.properies i a text
editor.
Go through the contants until you come to the EVENT_INFO/ERROR... constants and
add the english translation. Try to keep the list sorted in alphabetical order.

If the three steps are followed the Web-GUI will be automagicaly updated and no
changes need to be done to it.

Error and debug logs
--------------------

EJBCA uses the Apache Log4J package for debug-logging. This means that any class
that wants to do logging or console output MUST define:

/** Log4j instance */
private static Logger log = Logger.getLogger(<class>.class);

Logging is then done with:

    log.error("message");
    log.info("message");
    log.debug("message");

There is also a version of the command that takes an additional Exception as
argument, were the exception stack will be printed to the log.

Where the log ends up is defined in 'log4j.properties'.

Some classes have special pre-prepared logging constructs. They are:

    BaseSessionBean.java
    BaseAdminCommand.java

This means that classes inheriting from one of these classes does not have to
define their own logger, but can simply use:

    error("message");
    info("message");
    debug("message");

Debugging output for entrance and exit in methods can be added in the following
way:

public int myMethod(int arg) {
  log.debug(">myMethod("+arg+")");

  int ret = 0;
  ...

  log.debug("<meMethod: return "+ret);
  return ret;
}

Making session beans
--------------------

All session beans should inherit the class se.anatom.ejbca.BaseSessionBean.java.
When doing lookups for other beans from within the new bean, a simple construct
is provided and MUST be used:

For remote interfaces to other beans:

    /** Looks up a JNDI name using the (cached) InitialContext
     *@param jndiName the JNDI name to lookup.
     *@param type the class type to narrow the object to.
     *@return Object that can be casted to 'type'.
     */
    public Object lookup( String jndiName, Class type );


For local interfaces to other beans:
    /** Looks up a JNDI name using the (cached) InitialContext
     *@param jndiName the JNDI name to lookup.
     *@return Object that can be casted to 'type'.
     */
    public Object lookup( String jndiName);


Making entity beans
--------------------

All entity beans should inherit the class se.anatom.ejbca.BaseEntityBean.java.
When doing this, the standard methods like setting the context are already in
there. They
can however always be overriden.


CVS
---

All files should have the below part in the initial class comment:

@version $Id: DEVELOP,v 1.9 2003-03-11 09:46:04 anatom Exp $

Example:

/**
 * The main bean for the web interface, it contains all basic functions.
 *
 * @version $Id: DEVELOP,v 1.9 2003-03-11 09:46:04 anatom Exp $
 */

CA KeyStore architecture/creating a custom CA Keystore
--------------------------------------------------------------------------

The CA Keystore, where the CAs private key is stored and used is
defined by the interface se.anatom.ejbca.ca.sign.ISigningDevice.

By creating a new custom class and simply editing the property
'signingDeviceFactory' to point at the custom factory class that creates an
instance of the custom SigningDevice class in a thread-safe way.
It is recommended, but not required, that the Signing device implements a
Singleton.

The SigningDeviceFactory class MUST contain the method:

   /** Creates (if needed) the signing device and returns the object.
    * @prop Arguments needed fo?r the eventual creation of the object
    * @return An instance of the Signing device.
    */
    public synchronized ISigningDevice makeInstance(Properties prop) throws
    Exception {
        return PKCS12SigningDevice.instance(prop);
    }

CertificateStore/Publisher architecture
---------------------------------------

The CertificateStore/Publisher architecture is defined by the two interfaces
IPublisherSession and ICertificateStoreSession:

public interface IPublisherSession;
public interface ICertificateStoreSession extends IPublisherSession;

The CertificateStoreSession is the primary storage
for certificates and CRL. The CA always puts certificates and CRLs in the
CertificateStoreSession session bean defined in ca/ejb-jar.xml. The
CertificateStoreSession is also used to retrieve and find certificates,
retrieve CRLs, check for revocation etc. the CertificateStoreSession implements
the interface ICertificateStoreSession.

Certificates and CRLs can also be published to any number of other certificate
stores, which are defined by session beans PublisherSession1, PublisherSession2,
etc. A PublisherSession is a simple subset of the CertificateStoreSession and
can only be used to store certificates and CRLs. PublisherSession's implement
the interface IPublisherSession.

The IPublisherSession is a simple interface which is only used to store a
certificate or a CRL.
The ICertificateStoreSession extends the IPublisherSession interface with
capabilities to find certificates and CRL etc.
A class implementing the ICertificateStoreSession interface can thus also be
used a PublisherSession and a class implementing the IPublisherSession can
easily (well maybe not so easily) be extended to a fully fledged
CertificateStore.

This architecture gives us the choice of for example an SQL database aa
CertificateStoreSession where we also publish certificates to an LDAP directory,
or the LDAP directory as the primary CertificateStoreSession where we also
publish certificates to a specific SQL database for a specific purpose.

